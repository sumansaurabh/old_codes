THREE.BAS={},THREE.BAS.ShaderChunk={},THREE.BAS.ShaderChunk.animation_time="float tDelay = aAnimation.x;\nfloat tDuration = aAnimation.y;\nfloat tTime = clamp(uTime - tDelay, 0.0, tDuration);\nfloat tProgress = ease(tTime, 0.0, 1.0, tDuration);\n",THREE.BAS.ShaderChunk["catmull-rom"]="vec3 catmullRom(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t)\n{\n    vec3 v0 = (p2 - p0) * 0.5;\n    vec3 v1 = (p3 - p1) * 0.5;\n    float t2 = t * t;\n    float t3 = t * t * t;\n\n    return vec3((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\n}\n\nvec3 catmullRom(vec3 p0, vec3 p1, vec3 p2, vec3 p3, vec2 c, float t)\n{\n    vec3 v0 = (p2 - p0) * c.x;\n    vec3 v1 = (p3 - p1) * c.y;\n    float t2 = t * t;\n    float t3 = t * t * t;\n\n    return vec3((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\n}\n\nfloat catmullRom(float p0, float p1, float p2, float p3, float t)\n{\n    float v0 = (p2 - p0) * 0.5;\n    float v1 = (p3 - p1) * 0.5;\n    float t2 = t * t;\n    float t3 = t * t * t;\n\n    return float((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\n}\n\nfloat catmullRom(float p0, float p1, float p2, float p3, vec2 c, float t)\n{\n    float v0 = (p2 - p0) * c.x;\n    float v1 = (p3 - p1) * c.y;\n    float t2 = t * t;\n    float t3 = t * t * t;\n\n    return float((2.0 * p1 - 2.0 * p2 + v0 + v1) * t3 + (-3.0 * p1 + 3.0 * p2 - 2.0 * v0 - v1) * t2 + v0 * t + p1);\n}\n",THREE.BAS.ShaderChunk.cubic_bezier="vec3 cubicBezier(vec3 p0, vec3 c0, vec3 c1, vec3 p1, float t)\n{\n    vec3 tp;\n    float tn = 1.0 - t;\n\n    tp.xyz = tn * tn * tn * p0.xyz + 3.0 * tn * tn * t * c0.xyz + 3.0 * tn * t * t * c1.xyz + t * t * t * p1.xyz;\n\n    return tp;\n}\n",THREE.BAS.ShaderChunk.ease_in_cubic="float ease(float t, float b, float c, float d) {\n  return c*(t/=d)*t*t + b;\n}\n",THREE.BAS.ShaderChunk.ease_in_out_cubic="float ease(float t, float b, float c, float d) {\n  if ((t/=d/2.0) < 1.0) return c/2.0*t*t*t + b;\n  return c/2.0*((t-=2.0)*t*t + 2.0) + b;\n}\n",THREE.BAS.ShaderChunk.ease_in_quad="float ease(float t, float b, float c, float d) {\n  return c*(t/=d)*t + b;\n}\n",THREE.BAS.ShaderChunk.ease_out_back="float ease(float t, float b, float c, float d) {\n  float s = 1.70158;\n  return c*((t=t/d-1.0)*t*((s+1.0)*t + s) + 1.0) + b;\n}\n\nfloat ease(float t, float b, float c, float d, float s) {\n  return c*((t=t/d-1.0)*t*((s+1.0)*t + s) + 1.0) + b;\n}\n",THREE.BAS.ShaderChunk.ease_out_cubic="float ease(float t, float b, float c, float d) {\n  return c*((t=t/d - 1.0)*t*t + 1.0) + b;\n}\n",THREE.BAS.ShaderChunk.quaternion_rotation="vec3 rotateVector(vec4 q, vec3 v)\n{\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\nvec4 quatFromAxisAngle(vec3 axis, float angle)\n{\n    float halfAngle = angle * 0.5;\n    return vec4(axis.xyz * sin(halfAngle), cos(halfAngle));\n}\n",THREE.BAS.Utils={separateFaces:function(e){for(var t=[],r=0,a=e.faces.length;r<a;r++){var o=t.length,n=e.faces[r],i=n.a,s=n.b,c=n.c,f=e.vertices[i],l=e.vertices[s],h=e.vertices[c];t.push(f.clone()),t.push(l.clone()),t.push(h.clone()),n.a=o,n.b=o+1,n.c=o+2}e.vertices=t,delete e.__tmpVertices},tessellate:function(e,t){for(var r,a=[],o=[],n=t*t,i=0,s=e.faceVertexUvs.length;i<s;i++)o[i]=[];for(i=0,s=e.faces.length;i<s;i++){var c=e.faces[i];if(c instanceof THREE.Face3){var f=c.a,l=c.b,h=c.c,u=e.vertices[f],E=e.vertices[l],v=e.vertices[h],p=u.distanceToSquared(E),m=E.distanceToSquared(v),d=u.distanceToSquared(v);if(p>n||m>n||d>n){var x=e.vertices.length,y=c.clone(),T=c.clone();if(p>=m&&p>=d){if((S=u.clone()).lerp(E,.5),y.a=f,y.b=x,y.c=h,T.a=x,T.b=l,T.c=h,3===c.vertexNormals.length)(b=c.vertexNormals[0].clone()).lerp(c.vertexNormals[1],.5),y.vertexNormals[1].copy(b),T.vertexNormals[0].copy(b);if(3===c.vertexColors.length)(R=c.vertexColors[0].clone()).lerp(c.vertexColors[1],.5),y.vertexColors[1].copy(R),T.vertexColors[0].copy(R);r=0}else if(m>=p&&m>=d){if((S=E.clone()).lerp(v,.5),y.a=f,y.b=l,y.c=x,T.a=x,T.b=h,T.c=f,3===c.vertexNormals.length)(b=c.vertexNormals[1].clone()).lerp(c.vertexNormals[2],.5),y.vertexNormals[2].copy(b),T.vertexNormals[0].copy(b),T.vertexNormals[1].copy(c.vertexNormals[2]),T.vertexNormals[2].copy(c.vertexNormals[0]);if(3===c.vertexColors.length)(R=c.vertexColors[1].clone()).lerp(c.vertexColors[2],.5),y.vertexColors[2].copy(R),T.vertexColors[0].copy(R),T.vertexColors[1].copy(c.vertexColors[2]),T.vertexColors[2].copy(c.vertexColors[0]);r=1}else{var S,b,R;if((S=u.clone()).lerp(v,.5),y.a=f,y.b=l,y.c=x,T.a=x,T.b=l,T.c=h,3===c.vertexNormals.length)(b=c.vertexNormals[0].clone()).lerp(c.vertexNormals[2],.5),y.vertexNormals[2].copy(b),T.vertexNormals[0].copy(b);if(3===c.vertexColors.length)(R=c.vertexColors[0].clone()).lerp(c.vertexColors[2],.5),y.vertexColors[2].copy(R),T.vertexColors[0].copy(R);r=2}a.push(y,T),e.vertices.push(S);for(var H=0,A=e.faceVertexUvs.length;H<A;H++)if(e.faceVertexUvs[H].length){var _=e.faceVertexUvs[H][i],B=_[0],C=_[1],g=_[2];if(0===r){(M=B.clone()).lerp(C,.5);var k=[B.clone(),M.clone(),g.clone()],V=[M.clone(),C.clone(),g.clone()]}else if(1===r){(M=C.clone()).lerp(g,.5);k=[B.clone(),C.clone(),M.clone()],V=[M.clone(),g.clone(),B.clone()]}else{var M;(M=B.clone()).lerp(g,.5);k=[B.clone(),C.clone(),M.clone()],V=[M.clone(),C.clone(),g.clone()]}o[H].push(k,V)}}else{a.push(c);for(H=0,A=e.faceVertexUvs.length;H<A;H++)o[H].push(e.faceVertexUvs[H][i])}}}e.faces=a,e.faceVertexUvs=o},tessellateRepeat:function(e,t,r){for(var a=0;a<r;a++)THREE.BAS.Utils.tessellate(e,t)},subdivide:function(e,t){for(var r=!1,a=["a","b","c"];t-- >0;)s(e);function o(e,t,r){return r[Math.min(e,t)+"_"+Math.max(e,t)]}function n(e,t,r,a,o,n){var i,s=Math.min(e,t),c=Math.max(e,t),f=s+"_"+c;f in a?i=a[f]:(i={a:r[s],b:r[c],newEdge:null,faces:[]},a[f]=i);i.faces.push(o),n[e].edges.push(i),n[t].edges.push(i)}function i(e,t,r,a){e.push(new THREE.Face3(t,r,a))}function s(e){var t,s,c,f,l,h,u,E,v,p,m,d,x,y,T,S,b,R,H,A,_,B,C,g,k,V,M,G=new THREE.Vector3;for(h in function(e,t,r,a){var o,i,s;for(o=0,i=e.length;o<i;o++)r[o]={edges:[]};for(o=0,i=t.length;o<i;o++)n((s=t[o]).a,s.b,e,a,s,r),n(s.b,s.c,e,a,s,r),n(s.c,s.a,e,a,s,r)}(t=e.vertices,s=e.faces,p=new Array(t.length),m={}),d=[],m){for(T=m[h],S=new THREE.Vector3,R=3/8,H=1/8,2!=(A=T.faces.length)&&(R=.5,H=0,1!=A&&r&&console.warn("Subdivision Modifier: Number of connected faces != 2, is: ",A,T)),S.addVectors(T.a,T.b).multiplyScalar(R),G.set(0,0,0),E=0;E<A;E++){for(b=T.faces[E],v=0;v<3&&((y=t[b[a[v]]])===T.a||y===T.b);v++);G.add(y)}G.multiplyScalar(H),S.add(G),T.newEdge=d.length,d.push(S)}for(x=[],h=0,u=t.length;h<u;h++){for(V=t[h],3==(l=(k=p[h].edges).length)?_=3/16:l>3&&(_=3/(8*l)),B=1-l*_,C=_,l<=2&&(2==l?(r&&console.warn("2 connecting edges",k),B=.75,C=1/8):1==l?r&&console.warn("only 1 connecting edge"):0==l&&r&&console.warn("0 connecting edges")),M=V.clone().multiplyScalar(B),G.set(0,0,0),E=0;E<l;E++)y=(g=k[E]).a!==V?g.a:g.b,G.add(y);G.multiplyScalar(C),M.add(G),x.push(M)}c=x.concat(d);var P,w,N,U=x.length;for(f=[],h=0,u=s.length;h<u;h++)i(f,P=o((b=s[h]).a,b.b,m).newEdge+U,w=o(b.b,b.c,m).newEdge+U,N=o(b.c,b.a,m).newEdge+U),i(f,b.a,P,N),i(f,b.b,w,P),i(f,b.c,N,w);e.vertices=c,e.faces=f}delete e.__tmpVertices,e.computeFaceNormals(),e.computeVertexNormals()},computeCentroid:function(){var e=new THREE.Vector3;return function(t,r){var a=t.vertices[r.a],o=t.vertices[r.b],n=t.vertices[r.c];return e.x=(a.x+o.x+n.x)/3,e.y=(a.y+o.y+n.y)/3,e.z=(a.z+o.z+n.z)/3,e}}()},THREE.BAS.ModelBufferGeometry=function(e){THREE.BufferGeometry.call(this),this.modelGeometry=e,this.faceCount=this.modelGeometry.faces.length,this.vertexCount=this.modelGeometry.vertices.length,this.bufferIndices(),this.bufferPositions()},THREE.BAS.ModelBufferGeometry.prototype=Object.create(THREE.BufferGeometry.prototype),THREE.BAS.ModelBufferGeometry.prototype.constructor=THREE.BAS.ModelBufferGeometry,THREE.BAS.ModelBufferGeometry.prototype.bufferIndices=function(){var e=new Uint32Array(3*this.faceCount);this.setIndex(new THREE.BufferAttribute(e,1));for(var t=0,r=0;t<this.faceCount;t++,r+=3){var a=this.modelGeometry.faces[t];e[r]=a.a,e[r+1]=a.b,e[r+2]=a.c}},THREE.BAS.ModelBufferGeometry.prototype.bufferPositions=function(){for(var e=this.createAttribute("position",3).array,t=0,r=0;t<this.vertexCount;t++,r+=3){var a=this.modelGeometry.vertices[t];e[r]=a.x,e[r+1]=a.y,e[r+2]=a.z}},THREE.BAS.ModelBufferGeometry.prototype.bufferUVs=function(){for(var e=this.createAttribute("uv",2).array,t=0;t<this.faceCount;t++){var r,a=this.modelGeometry.faces[t];r=this.modelGeometry.faceVertexUvs[0][t][0],e[2*a.a]=r.x,e[2*a.a+1]=r.y,r=this.modelGeometry.faceVertexUvs[0][t][1],e[2*a.b]=r.x,e[2*a.b+1]=r.y,r=this.modelGeometry.faceVertexUvs[0][t][2],e[2*a.c]=r.x,e[2*a.c+1]=r.y}},THREE.BAS.ModelBufferGeometry.prototype.createAttribute=function(e,t){var r=new Float32Array(this.vertexCount*t),a=new THREE.BufferAttribute(r,t);return this.addAttribute(e,a),a},THREE.BAS.PrefabBufferGeometry=function(e,t){THREE.BufferGeometry.call(this),this.prefabGeometry=e,this.prefabCount=t,this.prefabVertexCount=e.vertices.length,this.bufferIndices(),this.bufferPositions()},THREE.BAS.PrefabBufferGeometry.prototype=Object.create(THREE.BufferGeometry.prototype),THREE.BAS.PrefabBufferGeometry.prototype.constructor=THREE.BAS.PrefabBufferGeometry,THREE.BAS.PrefabBufferGeometry.prototype.bufferIndices=function(){for(var e=this.prefabGeometry.faces.length,t=3*this.prefabGeometry.faces.length,r=[],a=0;a<e;a++){var o=this.prefabGeometry.faces[a];r.push(o.a,o.b,o.c)}var n=new Uint32Array(this.prefabCount*t);this.setIndex(new THREE.BufferAttribute(n,1));for(var i=0;i<this.prefabCount;i++)for(var s=0;s<t;s++)n[i*t+s]=r[s]+i*this.prefabVertexCount},THREE.BAS.PrefabBufferGeometry.prototype.bufferPositions=function(){for(var e=this.createAttribute("position",3).array,t=0,r=0;t<this.prefabCount;t++)for(var a=0;a<this.prefabVertexCount;a++,r+=3){var o=this.prefabGeometry.vertices[a];e[r]=o.x,e[r+1]=o.y,e[r+2]=o.z}},THREE.BAS.PrefabBufferGeometry.prototype.bufferUvs=function(){for(var e=this.prefabGeometry.faces.length,t=this.prefabVertexCount=this.prefabGeometry.vertices.length,r=[],a=0;a<e;a++){var o=this.prefabGeometry.faces[a],n=this.prefabGeometry.faceVertexUvs[0][a];r[o.a]=n[0],r[o.b]=n[1],r[o.c]=n[2]}for(var i=this.createAttribute("uv",2),s=0,c=0;s<this.prefabCount;s++)for(var f=0;f<t;f++,c+=2){var l=r[f];i.array[c]=l.x,i.array[c+1]=l.y}},THREE.BAS.PrefabBufferGeometry.prototype.computeVertexNormals=function(){var e=this.index,t=this.attributes,r=t.position.array;void 0===t.normal&&this.addAttribute("normal",new THREE.BufferAttribute(new Float32Array(r.length),3));for(var a,o,n,i=t.normal.array,s=new THREE.Vector3,c=new THREE.Vector3,f=new THREE.Vector3,l=new THREE.Vector3,h=new THREE.Vector3,u=e.array,E=3*this.prefabGeometry.faces.length,v=0;v<E;v+=3)a=3*u[v+0],o=3*u[v+1],n=3*u[v+2],s.fromArray(r,a),c.fromArray(r,o),f.fromArray(r,n),l.subVectors(f,c),h.subVectors(s,c),l.cross(h),i[a]+=l.x,i[a+1]+=l.y,i[a+2]+=l.z,i[o]+=l.x,i[o+1]+=l.y,i[o+2]+=l.z,i[n]+=l.x,i[n+1]+=l.y,i[n+2]+=l.z;for(var p=1;p<this.prefabCount;p++)for(var m=0;m<E;m++)i[p*E+m]=i[m];this.normalizeNormals(),t.normal.needsUpdate=!0},THREE.BAS.PrefabBufferGeometry.prototype.createAttribute=function(e,t,r){var a=new Float32Array(this.prefabCount*this.prefabVertexCount*t),o=new THREE.BufferAttribute(a,t);if(this.addAttribute(e,o),r)for(var n=0,i=0;n<this.prefabCount;n++)for(var s=r(n,this.prefabCount),c=0;c<this.prefabVertexCount;c++)for(var f=0;f<t;f++)a[i++]="number"==typeof s?s:s[f];return o},THREE.BAS.PrefabBufferGeometry.prototype.setAttribute4=function(e,t){var r,a,o=0,n=this.geometry.attributes[e].array;for(r=0;r<t.length;r++){var i=t[r];for(a=0;a<this.prefabVertexCount;a++)n[o++]=i.x,n[o++]=i.y,n[o++]=i.z,n[o++]=i.w}this.geometry.attributes[e].needsUpdate=!0},THREE.BAS.PrefabBufferGeometry.prototype.setAttribute3=function(e,t){var r,a,o=0,n=this.geometry.attributes[e].array;for(r=0;r<t.length;r++){var i=t[r];for(a=0;a<this.prefabVertexCount;a++)n[o++]=i.x,n[o++]=i.y,n[o++]=i.z}this.geometry.attributes[e].needsUpdate=!0},THREE.BAS.PrefabBufferGeometry.prototype.setAttribute2=function(e,t){var r,a,o=0,n=this.geometry.attributes[e].array;for(r=0;r<this.prefabCount;r++){var i=t[r];for(a=0;a<this.prefabVertexCount;a++)n[o++]=i.x,n[o++]=i.y}this.geometry.attributes[e].needsUpdate=!0},THREE.BAS.BaseAnimationMaterial=function(e){THREE.ShaderMaterial.call(this),this.shaderFunctions=[],this.shaderParameters=[],this.shaderVertexInit=[],this.shaderTransformNormal=[],this.shaderTransformPosition=[],this.setValues(e)},THREE.BAS.BaseAnimationMaterial.prototype=Object.create(THREE.ShaderMaterial.prototype),THREE.BAS.BaseAnimationMaterial.prototype.constructor=THREE.BAS.BaseAnimationMaterial,THREE.BAS.BaseAnimationMaterial.prototype._concatVertexShader=function(){return""},THREE.BAS.BaseAnimationMaterial.prototype._concatFunctions=function(){return this.shaderFunctions.join("\n")},THREE.BAS.BaseAnimationMaterial.prototype._concatParameters=function(){return this.shaderParameters.join("\n")},THREE.BAS.BaseAnimationMaterial.prototype._concatVertexInit=function(){return this.shaderVertexInit.join("\n")},THREE.BAS.BaseAnimationMaterial.prototype._concatTransformNormal=function(){return this.shaderTransformNormal.join("\n")},THREE.BAS.BaseAnimationMaterial.prototype._concatTransformPosition=function(){return this.shaderTransformPosition.join("\n")},THREE.BAS.BaseAnimationMaterial.prototype.setUniformValues=function(e){for(var t in e)if(t in this.uniforms){var r=this.uniforms[t],a=e[t];switch(r.type){case"c":r.value.set(a);break;case"v2":case"v3":case"v4":r.value.copy(a);break;case"f":case"t":default:r.value=a}}},THREE.BAS.BasicAnimationMaterial=function(e,t){THREE.BAS.BaseAnimationMaterial.call(this,e);var r=THREE.ShaderLib.basic;this.uniforms=THREE.UniformsUtils.merge([r.uniforms,this.uniforms]),this.lights=!1,this.vertexShader=this._concatVertexShader(),this.fragmentShader=r.fragmentShader,t.map&&(this.defines.USE_MAP=""),t.normalMap&&(this.defines.USE_NORMALMAP=""),this.setUniformValues(t)},THREE.BAS.BasicAnimationMaterial.prototype=Object.create(THREE.BAS.BaseAnimationMaterial.prototype),THREE.BAS.BasicAnimationMaterial.prototype.constructor=THREE.BAS.BasicAnimationMaterial,THREE.BAS.BasicAnimationMaterial.prototype._concatVertexShader=function(){return[THREE.ShaderChunk.common,THREE.ShaderChunk.uv_pars_vertex,THREE.ShaderChunk.uv2_pars_vertex,THREE.ShaderChunk.envmap_pars_vertex,THREE.ShaderChunk.color_pars_vertex,THREE.ShaderChunk.morphtarget_pars_vertex,THREE.ShaderChunk.skinning_pars_vertex,THREE.ShaderChunk.logdepthbuf_pars_vertex,this._concatFunctions(),this._concatParameters(),"void main() {",this._concatVertexInit(),THREE.ShaderChunk.uv_vertex,THREE.ShaderChunk.uv2_vertex,THREE.ShaderChunk.color_vertex,THREE.ShaderChunk.skinbase_vertex,"\t#ifdef USE_ENVMAP",THREE.ShaderChunk.beginnormal_vertex,this._concatTransformNormal(),THREE.ShaderChunk.morphnormal_vertex,THREE.ShaderChunk.skinnormal_vertex,THREE.ShaderChunk.defaultnormal_vertex,"\t#endif",THREE.ShaderChunk.begin_vertex,this._concatTransformPosition(),THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.skinning_vertex,THREE.ShaderChunk.project_vertex,THREE.ShaderChunk.logdepthbuf_vertex,THREE.ShaderChunk.worldpos_vertex,THREE.ShaderChunk.envmap_vertex,"}"].join("\n")},THREE.BAS.PhongAnimationMaterial=function(e,t){THREE.BAS.BaseAnimationMaterial.call(this,e);var r=THREE.ShaderLib.phong;this.uniforms=THREE.UniformsUtils.merge([r.uniforms,this.uniforms]),this.lights=!0,this.vertexShader=this._concatVertexShader(),this.fragmentShader=r.fragmentShader,t.map&&(this.defines.USE_MAP=""),t.normalMap&&(this.defines.USE_NORMALMAP=""),this.setUniformValues(t)},THREE.BAS.PhongAnimationMaterial.prototype=Object.create(THREE.BAS.BaseAnimationMaterial.prototype),THREE.BAS.PhongAnimationMaterial.prototype.constructor=THREE.BAS.PhongAnimationMaterial,THREE.BAS.PhongAnimationMaterial.prototype._concatVertexShader=function(){return["#define PHONG","varying vec3 vViewPosition;","#ifndef FLAT_SHADED","\tvarying vec3 vNormal;","#endif",THREE.ShaderChunk.common,THREE.ShaderChunk.uv_pars_vertex,THREE.ShaderChunk.uv2_pars_vertex,THREE.ShaderChunk.displacementmap_pars_vertex,THREE.ShaderChunk.envmap_pars_vertex,THREE.ShaderChunk.lights_phong_pars_vertex,THREE.ShaderChunk.color_pars_vertex,THREE.ShaderChunk.morphtarget_pars_vertex,THREE.ShaderChunk.skinning_pars_vertex,THREE.ShaderChunk.shadowmap_pars_vertex,THREE.ShaderChunk.logdepthbuf_pars_vertex,this._concatFunctions(),this._concatParameters(),"void main() {",this._concatVertexInit(),THREE.ShaderChunk.uv_vertex,THREE.ShaderChunk.uv2_vertex,THREE.ShaderChunk.color_vertex,THREE.ShaderChunk.beginnormal_vertex,this._concatTransformNormal(),THREE.ShaderChunk.morphnormal_vertex,THREE.ShaderChunk.skinbase_vertex,THREE.ShaderChunk.skinnormal_vertex,THREE.ShaderChunk.defaultnormal_vertex,"#ifndef FLAT_SHADED","\tvNormal = normalize( transformedNormal );","#endif",THREE.ShaderChunk.begin_vertex,this._concatTransformPosition(),THREE.ShaderChunk.displacementmap_vertex,THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.skinning_vertex,THREE.ShaderChunk.project_vertex,THREE.ShaderChunk.logdepthbuf_vertex,"\tvViewPosition = - mvPosition.xyz;",THREE.ShaderChunk.worldpos_vertex,THREE.ShaderChunk.envmap_vertex,THREE.ShaderChunk.lights_phong_vertex,THREE.ShaderChunk.shadowmap_vertex,"}"].join("\n")};